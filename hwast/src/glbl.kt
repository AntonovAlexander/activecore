/*
 * glbl.kt
 *
 *  Created on: 05.06.2019
 *      Author: Alexander Antonov <antonov.alex.alex@gmail.com>
 *     License: See LICENSE file for details
 */

package hwast

import kotlin.math.log2
import java.io.OutputStreamWriter
import java.text.SimpleDateFormat
import java.util.Date
import kotlin.collections.ArrayList

fun ERROR(err_string : String) {
    throw Exception("ActiveCore ERROR: " + err_string)
}

fun WARNING(err_string : String) {
    println("ActiveCore WARNING: " + err_string)
}

fun CRITICAL(err_string : String) {
    println("ActiveCore CRITICAL WARNING: " + err_string)
}

fun MSG(msg_string : String) {
    println("ActiveCore: " + msg_string)
}

fun MSG(DEBUG_FLAG : Boolean, msg_string : String) {
    if (DEBUG_FLAG) MSG(msg_string)
}

var DUMMY_STRUCT = hw_struct("GEN_DUMMY")

fun GetWidthToContain(variations: Int) : Int {
    var ret_width = Math.ceil(log2(variations.toDouble())).toInt()
    if (ret_width < 1) ret_width = 1
    return ret_width
}

fun <T> UniteArrayLists(List0 : ArrayList<T>, List1 : ArrayList<T>) : ArrayList<T> {
    var ret_ArrayList = ArrayList<T>()
    ret_ArrayList.addAll(List0)
    for (elem1 in List1) {
        if (!ret_ArrayList.contains(elem1)) ret_ArrayList.add(elem1)
    }
    return ret_ArrayList
}

fun <T> CrossArrayLists(List0 : ArrayList<T>, List1 : ArrayList<T>) : ArrayList<T> {
    var ret_ArrayList = ArrayList<T>()
    for (elem0 in List0) {
        if (List1.contains(elem0)) ret_ArrayList.add(elem0)
    }
    return ret_ArrayList
}

fun WriteGenSrcHeader(wrFile : OutputStreamWriter, SrcType : String) {
    val simpleDateFormat = SimpleDateFormat("yyyy-MM-dd")
    wrFile.write("// ===========================================================\n")
    wrFile.write("// " + SrcType + " generated by ActiveCore framework\n")
    wrFile.write("// Date: " + simpleDateFormat.format(Date()) + "\n")
    wrFile.write("// Copyright Alexander Antonov <antonov.alex.alex@gmail.com>\n")
    wrFile.write("// ===========================================================\n\n")
}

fun TranslateVar(var_in : hw_var, var_dict: MutableMap<hw_var, hw_var>) : hw_var {
    var ret_var = var_dict[var_in]
    if (ret_var != null) return ret_var
    else {
        MSG("Possible var translations for variable " + var_in.name + ":")
        for (var_entry in var_dict) {
            println("-- " + var_entry.key.name)
        }
        ERROR("Translation error for var " + var_in.name + "!")
    }
    throw Exception()
}

fun TranslateParam(param : hw_param, var_dict: MutableMap<hw_var, hw_var>) : hw_param {
    if (param is hw_imm) return param
    else if (param is hw_var) return TranslateVar(param, var_dict)
    else {
        ERROR("Type unrecognized!")
        throw Exception()
    }
}

fun ReconstructFractions(fracs_in : hw_fracs, var_dict: MutableMap<hw_var, hw_var>) : hw_fracs {
    var fractions = hw_fracs()
    for (src_fraction in fracs_in) {
        if (src_fraction is hw_frac_C) fractions.add(src_fraction)
        else if (src_fraction is hw_frac_V) fractions.add(hw_frac_V(TranslateVar(src_fraction.index, var_dict)))
        else if (src_fraction is hw_frac_CC) fractions.add(src_fraction)
        else if (src_fraction is hw_frac_CV) fractions.add(hw_frac_CV(src_fraction.msb, TranslateVar(src_fraction.lsb, var_dict)))
        else if (src_fraction is hw_frac_VC) fractions.add(hw_frac_VC(TranslateVar(src_fraction.msb, var_dict), src_fraction.lsb))
        else if (src_fraction is hw_frac_VV) fractions.add(hw_frac_VV(TranslateVar(src_fraction.msb, var_dict), TranslateVar(src_fraction.lsb, var_dict)))
        else if (src_fraction is hw_frac_SubStruct) fractions.add(src_fraction)
        else ERROR("dimensions error")
    }
    return fractions
}
