/*
 * util.kt
 *
 *  Created on: 05.06.2019
 *      Author: Alexander Antonov <antonov.alex.alex@gmail.com>
 *     License: See LICENSE file for details
 */

package hwast

import kotlin.math.log2
import java.io.OutputStreamWriter
import java.text.SimpleDateFormat
import java.util.Date
import kotlin.collections.ArrayList
import java.io.FileOutputStream
import java.net.InetAddress

val FRAMEWORK_NAME = "ActiveCore"

enum class DEBUG_LEVEL(val level: Int) {
    FULL(2),
    PARTIAL(1),
    SILENT(0)
}

var LogFile = FileOutputStream("log.txt", false).writer()
var LogFile_header_written = false

fun ProcessLogFileStream() {
    if (!LogFile_header_written) {
        val simpleDateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
        LogFile.write("// ===========================================================\n")
        LogFile.write("// Log generated by ActiveCore framework\n")
        LogFile.write("// Host: " + InetAddress.getLocalHost().getHostName() + "\n")
        LogFile.write("// Date: " + simpleDateFormat.format(Date()) + "\n")
        LogFile.write("// ===========================================================\n\n")
        LogFile_header_written = true
    } else {
        LogFile = FileOutputStream("log.txt", true).writer()
    }
}

fun NEWLINE() {
    ProcessLogFileStream()
    print("\n")
    LogFile.write("\n")
    LogFile.close()
}

fun MSG(msg_string : String) {
    ProcessLogFileStream()
    val str = FRAMEWORK_NAME + ": " + msg_string + "\n"
    print(str)
    LogFile.write(str)
    LogFile.close()
}

fun MSG(debug_lvl : DEBUG_LEVEL, msg_string : String) {
    if (debug_lvl.level > 0) MSG(msg_string)
}

fun WARNING(err_string : String) {
    ProcessLogFileStream()
    val str = FRAMEWORK_NAME + " WARNING: " + err_string + "\n"
    print(str)
    LogFile.write(str)
    LogFile.close()
}

fun CRITICAL(err_string : String) {
    ProcessLogFileStream()
    val str = FRAMEWORK_NAME + " CRITICAL WARNING: " + err_string + "\n"
    print(str)
    LogFile.write(str)
    LogFile.close()
}

fun ERROR(err_string : String) {
    ProcessLogFileStream()
    val str = FRAMEWORK_NAME + " ERROR: " + err_string
    print(str)
    LogFile.write(str)
    LogFile.close()
    throw Exception(str)
}

var DUMMY_STRUCT = hw_struct("GEN_DUMMY")

fun GetWidthToContain(variations: Int) : Int {
    var ret_width = Math.ceil(log2(variations.toDouble())).toInt()
    if (ret_width < 1) ret_width = 1
    return ret_width
}

fun <T> UniteArrayLists(List0 : ArrayList<T>, List1 : ArrayList<T>) : ArrayList<T> {
    var ret_ArrayList = ArrayList<T>()
    ret_ArrayList.addAll(List0)
    for (elem1 in List1) {
        if (!ret_ArrayList.contains(elem1)) ret_ArrayList.add(elem1)
    }
    return ret_ArrayList
}

fun <T> CrossArrayLists(List0 : ArrayList<T>, List1 : ArrayList<T>) : ArrayList<T> {
    var ret_ArrayList = ArrayList<T>()
    for (elem0 in List0) {
        if (List1.contains(elem0)) ret_ArrayList.add(elem0)
    }
    return ret_ArrayList
}

fun WriteGenSrcHeader(wrFile : OutputStreamWriter, SrcType : String) {
    val simpleDateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
    wrFile.write("// ===========================================================\n")
    wrFile.write("// " + SrcType + " generated by ActiveCore framework\n")
    wrFile.write("// Date: " + simpleDateFormat.format(Date()) + "\n")
    wrFile.write("// Copyright Alexander Antonov <antonov.alex.alex@gmail.com>\n")
    wrFile.write("// ===========================================================\n\n")
}

fun DisplayTranslationError(var_in : hw_var, var_dict: MutableMap<hw_var, hw_var>) {
    var type_string = "var"
    if (var_in is hw_var_frac) type_string = "frac, src var: " + var_in.src_var.name + ", fracs: " + var_in.GetFracString()
    MSG("Possible var translations for variable " + var_in.name + " (type: " + type_string + "):")
    for (var_entry in var_dict) {
        var key_type_string = "var"
        if (var_entry.key is hw_var_frac) key_type_string = "frac"
        var value_type_string = "var"
        if (var_entry.value is hw_var_frac) value_type_string = "frac"
        MSG("-- key: " + var_entry.key.name + " (" + key_type_string + "), value: " + var_entry.value.name + " (" + value_type_string + ")")
    }
    ERROR("Translation error for var " + var_in.name + "!")
}

fun TranslateFractions(depow_fractions_in: hw_fracs, var_dict: MutableMap<hw_var, hw_var>) : hw_fracs {
    var depow_fractions_out = hw_fracs()
    for (frac in depow_fractions_in) {
        if (frac is hw_frac_C)              depow_fractions_out.add(frac)
        else if (frac is hw_frac_V)         depow_fractions_out.add(hw_frac_V(TranslateVar(frac.index, var_dict)))
        else if (frac is hw_frac_CC)        depow_fractions_out.add(frac)
        else if (frac is hw_frac_CV)        depow_fractions_out.add(hw_frac_CV(frac.msb, TranslateVar(frac.lsb, var_dict)))
        else if (frac is hw_frac_VC)        depow_fractions_out.add(hw_frac_VC(TranslateVar(frac.msb, var_dict), frac.lsb))
        else if (frac is hw_frac_VV)        depow_fractions_out.add(hw_frac_VV(TranslateVar(frac.msb, var_dict), TranslateVar(frac.lsb, var_dict)))
        else if (frac is hw_frac_SubStruct) depow_fractions_out.add(frac)
        else ERROR("TranslateFractions error")
    }
    return depow_fractions_out
}

fun TranslateVar(var_in : hw_var, var_dict: MutableMap<hw_var, hw_var>) : hw_var {
    if (var_in is hw_var_frac) {
        var src_var = var_dict[var_in.src_var]
        if (src_var != null) return src_var.GetFracRef(TranslateFractions(var_in.depow_fractions, var_dict))
        else DisplayTranslationError(var_in, var_dict)
    } else {
        var ret_var = var_dict[var_in]
        if (ret_var != null) return ret_var
        else DisplayTranslationError(var_in, var_dict)
    }
    throw Exception()
}

fun TranslateParam(param : hw_param, var_dict: MutableMap<hw_var, hw_var>) : hw_param {
    if (param is hw_imm) return param
    else if (param is hw_var) return TranslateVar(param, var_dict)
    else {
        ERROR("Type unrecognized!")
        throw Exception()
    }
}

fun ReconstructFractions(fracs_in : hw_fracs, var_dict: MutableMap<hw_var, hw_var>) : hw_fracs {
    var fractions = hw_fracs()
    for (src_fraction in fracs_in) {
        if (src_fraction is hw_frac_C) fractions.add(src_fraction)
        else if (src_fraction is hw_frac_V) fractions.add(hw_frac_V(TranslateVar(src_fraction.index, var_dict)))
        else if (src_fraction is hw_frac_CC) fractions.add(src_fraction)
        else if (src_fraction is hw_frac_CV) fractions.add(hw_frac_CV(src_fraction.msb, TranslateVar(src_fraction.lsb, var_dict)))
        else if (src_fraction is hw_frac_VC) fractions.add(hw_frac_VC(TranslateVar(src_fraction.msb, var_dict), src_fraction.lsb))
        else if (src_fraction is hw_frac_VV) fractions.add(hw_frac_VV(TranslateVar(src_fraction.msb, var_dict), TranslateVar(src_fraction.lsb, var_dict)))
        else if (src_fraction is hw_frac_SubStruct) fractions.add(src_fraction)
        else ERROR("dimensions error")
    }
    return fractions
}
